@using StoneHammer.Systems
@inject CombatService CombatService
@implements IDisposable

@if (CombatService.IsFighting)
{
    <div class="combat-overlay">
        <!-- Top: Log -->
        <div class="combat-log">
            @CombatService.CombatLog
        </div>
        <!-- Floating Units (Positioned by JS) -->
        <!-- Enemies -->
        @foreach(var enemy in CombatService.Enemies)
        {
            @if (enemy.HP > 0 || (DateTime.Now - enemy.LastDamageTime).TotalSeconds < 1.0)
            {
                <div id="@("ui-" + enemy.ModelId)" class="combat-unit enemy @(_targetMode && _pendingTargetType == "Enemy" ? "targetable" : "")" 
                     @onclick="() => SelectTarget(enemy)" style="display: none;"> <!-- Hidden until positioned -->
                    <div class="unit-name">@enemy.Name</div>
                    <div class="unit-hp-bar">
                        <div class="fill" style="width: @(GetHpPercent(enemy))%"></div>
                    </div>
                    <div class="unit-hp-text">@enemy.HP / @enemy.MaxHP</div>
                    
                     <!-- Floating Text -->
                    @if ((DateTime.Now - enemy.LastDamageTime).TotalSeconds < 1.0)
                    {
                        <div class="damage-number @enemy.LastDamageType">
                            @enemy.LastDamageAmount
                        </div>
                    }
                </div>
            }
        }

        <!-- Heroes -->
        @foreach(var hero in CombatService.Heroes)
        {
            @if (hero.HP > 0)
            {
                <div id="@("ui-" + hero.ModelId)" class="combat-unit hero @(_selectedHero == hero ? "selected" : "") @(_targetMode && _pendingTargetType == "Friendly" ? "targetable" : "")"
                     @onclick="() => SelectTarget(hero)" style="display: none;">
                    <div class="unit-model">@(hero.Name.Substring(0,1))</div>
                    <div class="unit-info">
                         <!-- Simplified for Floating UI -->
                        <div class="name">@hero.Name</div>
            <!-- HP Bar -->
            <div class="unit-hp-bar">
                <div class="fill" style="width: @(GetHpPercent(hero))%;"></div>
            </div>
            <div class="hp-text">@hero.HP / @hero.MaxHP</div>
            
            <!-- Floating Text -->
            @if ((DateTime.Now - hero.LastDamageTime).TotalSeconds < 1.0)
            {
                <div class="damage-number @hero.LastDamageType">
                    @hero.LastDamageAmount
                </div>
            }
            
            <!-- Resource Bar -->
            @if(hero.SourceCharacter != null)
            {
                <div class="res-bar-container">
                    <div class="res-bar-fill" 
                         style="width: @(GetResourcePercent(hero))%; background: @hero.SourceCharacter.GetResourceColor()">
                    </div>
                    <div class="res-text">@hero.SourceCharacter.CurrentMana / @hero.SourceCharacter.MaxMana</div>
                </div>
            }
                        <div class="action-preview">
                            @(hero.QueuedAction?.Type ?? "...")
                        </div>
                    </div>
                </div>
            }
        }

        <!-- CENTER: Command Panel -->
        @if (CombatService.Phase == CombatPhase.Input && _selectedHero != null)
        {
            <div class="command-panel-wrapper center-screen">
                <div class="command-panel">
                    <div class="hero-portrait">@(_selectedHero.Name.Substring(0,1))</div>
                    <div class="menu-title">@_selectedHero.Name</div>
                    
                    @if (!_targetMode)
                    {
                        <div class="action-grid">
                <button class="btn-action @(_pendingAction == "Attack" ? "active" : "")" 
                        @onclick='() => SetAction("Attack")'>
                    ‚öîÔ∏è Attack
                </button>
                
                <button class="btn-action @(_pendingAction == "Defend" ? "active" : "")" 
                        @onclick='() => SetAction("Defend")'>
                    üõ°Ô∏è Defend
                </button>
                
                <!-- Dynamic Skills -->
                @if(_selectedHero?.SourceCharacter != null)
                {
                    @foreach(var skill in _selectedHero.SourceCharacter.Skills)
                    {
                        bool canAfford = _selectedHero.SourceCharacter.CurrentMana >= skill.ManaCost;
                        <button class="btn-action skill @(_pendingAction == skill.Name ? "active" : "")" 
                                disabled="@(!canAfford)"
                                title="@skill.Description (@skill.ManaCost @(_selectedHero.SourceCharacter.GetResourceName()))"
                                @onclick='() => SetAction(skill.Name)'>
                            @skill.Icon @skill.Name
                            <span class="cost">@skill.ManaCost</span>
                        </button>
                    }
                }
            </div>
            
            <!-- Target Selection Message -->
            <div class="sub-text">Select an action or target.</div>
            <div class="btn-grid">
                <button @onclick="ToggleAuto" class="btn-auto">ü§ñ Auto</button>
                <button @onclick="SkipHero" class="skip-btn">Skip ></button>
            </div>
                    }
                    else
                    {
                        <div class="menu-title">SELECT TARGET</div>
                        <div class="sub-text">Click a @(_pendingTargetType == "Enemy" ? "Enemy" : "Ally")...</div>
                        <button class="btn-cancel" @onclick="CancelTargeting">Cancel</button>
                    }
                </div>
            </div>
        }
        }
        }

        <!-- LOOT OVERLAY -->
        @if (CombatService.LootOpen)
        {
            <div class="loot-overlay">
                <div class="loot-window">
                    <div class="loot-title">Victory!</div>
                    <div class="loot-gold">Found @CombatService.CurrentLootGold Gold</div>
                    
                    <div class="loot-grid">
                        @foreach(var item in CombatService.CurrentLootItems)
                        {
                            <div class="loot-item @item.Rarity" title="@item.Description">
                                <div class="item-icon">@item.Icon</div>
                                <div class="item-details">
                                    <div class="item-name">@item.Name</div>
                                    <div class="item-type">@item.Rarity @item.Type</div>
                                </div>
                            </div>
                        }
                    </div>

                    <div class="loot-actions">
                        <button class="btn-take" @onclick="TakeAllLoot">Take All</button>
                    </div>
                </div>
            </div>
        }
    </div>
}

@code {
    private CombatEntity? _selectedHero;
    private bool _targetMode = false;
    private string _pendingAction = "";
    private string _pendingTargetType = ""; // "Enemy" or "Friendly"

    protected override void OnInitialized()
    {
        CombatService.OnStateChanged += HandleStateChange;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (CombatService.IsFighting)
        {
            // Tell JS to start tracking positions
            var ids = CombatService.Heroes.Concat(CombatService.Enemies).Select(x => x.ModelId).ToList();
            await CombatService.JS.InvokeVoidAsync("stoneHammer.startUITracking", ids);
        }
    }

    private void HandleStateChange()
    {
        // Auto-Selection Logic
        if (CombatService.Phase == CombatPhase.Input)
        {
            // If no hero selected, or current one is done, find next
            if (_selectedHero == null || (_selectedHero.QueuedAction != null))
            {
                 AutoSelectNext();
            }
        }
        StateHasChanged();
    }

    private void SkipHero()
    {
        if (_selectedHero != null)
        {
             // Wait logic? Or just null action?
             CombatService.QueueAction(_selectedHero, "Wait");
             AutoSelectNext();
        }
    }

    private void SetAction(string action)
    {
        _pendingAction = action;
        
        if (action == "Defend")
        {
            // Instant
            CombatService.QueueAction(_selectedHero, action);
            AutoSelectNext();
        }
        else if (action == "Attack")
        {
            _targetMode = true;
            _pendingTargetType = "Enemy";
        }
        else 
        {
            // Skill Logic - Lookup skill to find target type
            var skill = _selectedHero?.SourceCharacter?.Skills.FirstOrDefault(s => s.Name == action);
            if (skill != null)
            {
                _targetMode = true;
                // Heuristic: "Heal" is Friendly, others Enemy?
                // Ideally Skill class has TargetType. For now, hardcode "Heal".
                _pendingTargetType = (skill.Name.Contains("Heal")) ? "Friendly" : "Enemy";
            }
        }
        
        StateHasChanged();
    }

    private void SelectTarget(CombatEntity target)
    {
        if (!_targetMode || _selectedHero == null) return;
        
        // Validate Target Type
        bool valid = false;
        if (_pendingTargetType == "Enemy" && !target.IsHero) valid = true;
        if (_pendingTargetType == "Friendly" && target.IsHero) valid = true;

        if (valid)
        {
            CombatService.QueueAction(_selectedHero, _pendingAction, target);
            _targetMode = false;
            AutoSelectNext();
        }
    }

    private void CancelTargeting()
    {
        _targetMode = false;
    }

    // Crucial: Moves to next hero OR starts round
    private async void AutoSelectNext()
    {
        if (CombatService.Heroes.Count == 0) return; // Wait for spawn

        // Find first hero with no action and > 0 HP
        var next = CombatService.Heroes.FirstOrDefault(h => h.QueuedAction == null && h.HP > 0);

        if (next != null)
        {
            _selectedHero = next;
            _targetMode = false;
            StateHasChanged();
        }
        else
        {
            // ALL HEROES READY -> EXECUTE ROUND
            _selectedHero = null;
            StateHasChanged();
            
            // Brief delay for visual clarity?
            await Task.Delay(500);
            await CombatService.ExecuteRound();
        }
    }

    private double GetHpPercent(CombatEntity e) => (double)e.HP / e.MaxHP * 100;
    
    private double GetResourcePercent(CombatEntity e)
    {
        if (e.SourceCharacter == null || e.SourceCharacter.MaxMana == 0) return 0;
        return (double)e.SourceCharacter.CurrentMana / e.SourceCharacter.MaxMana * 100;
    }

    private void ToggleAuto()
    {
        CombatService.ToggleAutoBattle();
        // If we just turned it on, we might need to kickstart the loop
        if (CombatService.IsAutoBattling)
        {
            // AutoSelectNext logic will likely handle it via StateHasChanged, 
            // but we can force a check.
             AutoSelectNext(); 
        }
    }

    private async Task TakeAllLoot()
    {
        // Add Gold
        if (CombatService.Heroes.Any())
        {
             // Give to first hero (shared party wallet eventually)
             CombatService.Heroes.First().SourceCharacter.Gold += CombatService.CurrentLootGold;
        }

        // Add Items
        foreach(var item in CombatService.CurrentLootItems)
        {
            if (CombatService.Heroes.Any())
            {
                CombatService.Heroes.First().SourceCharacter.Inventory.Add(item);
            }
        }
        
        CombatService.ClearLoot();
        await CombatService.CloseLoot();
    }

    public void Dispose()
    {
        CombatService.OnStateChanged -= HandleStateChange;
    }
}

<style>
    .combat-overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; z-index: 2000; font-family: 'Segoe UI', sans-serif;
    }
    
    .combat-log {
        position: absolute; top: 10%; width: 100%; text-align: center;
        text-shadow: 0 0 5px black; font-size: 1.5rem; color: #fff; font-weight: bold;
    }

    /* Floating Units */
    .combat-unit {
        position: absolute; /* Floating */
        width: 120px; padding: 5px; 
        background: rgba(0,0,0,0.7); border: 2px solid #555;
        border-radius: 6px; color: white; 
        transition: transform 0.1s; pointer-events: auto; cursor: pointer;
        display: flex; flex-direction: column; align-items: center;
        font-size: 12px;
        transform: translate(-50%, -100%); /* Center horizontally, sit ABOVE point */
    }
    
    .combat-unit.enemy:hover { border-color: red; z-index: 2020; }
    .combat-unit.hero:hover { border-color: gold; z-index: 2020; }
    
    .combat-unit.hero.selected { border-color: gold; box-shadow: 0 0 15px gold; scale: 1.1; z-index: 2100; }
    .combat-unit.targetable { border-color: red; box-shadow: 0 0 15px red; cursor: crosshair; animation: pulse 1s infinite; }
    
    .damage-number {
        position: absolute; top: -30px; left: 50%; transform: translateX(-50%);
        font-size: 24px; font-weight: bold; z-index: 3000;
        text-shadow: 0 0 3px black, 0 0 5px black;
        opacity: 0; pointer-events: none;
        animation: floatUp 1s forwards;
    }
    .damage-number.Phys { color: white; }
    .damage-number.Crit { color: #ffeb3b; font-size: 32px; text-shadow: 0 0 10px gold; }
    .damage-number.Magic { color: #2196f3; }
    .damage-number.Heal { color: #4caf50; }

    @@keyframes floatUp {
        0% { transform: translate(-50%, 0) scale(0.5); opacity: 0; }
        20% { transform: translate(-50%, -10px) scale(1.2); opacity: 1; }
        100% { transform: translate(-50%, -50px) scale(1); opacity: 0; }
    }
    
    @@keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }
    
    .unit-hp-bar { width: 100%; height: 4px; background: #333; margin: 2px 0; }
    .unit-hp-bar .fill { height: 100%; background: #00ff00; }
    .enemy .unit-hp-bar .fill { background: #ff0000; }

    /* CENTER COMMAND PANEL */
    .center-screen {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        pointer-events: auto;
    }
    
    .command-panel {
        width: 250px; padding: 20px; background: rgba(0,0,20,0.95); 
        border: 2px solid gold; border-radius: 12px;
        box-shadow: 0 0 30px rgba(0,0,0,0.8);
        display: flex; flex-direction: column; align-items: center; gap: 10px;
    }

    .hero-portrait {
        width: 50px; height: 50px; border-radius: 50%; background: #444; border: 2px solid white;
        display: flex; justify-content: center; align-items: center; font-size: 24px; font-weight: bold;
        margin-bottom: 5px; color: white;
    }
    .hp-text { position: absolute; width: 100%; text-align: center; top: 0; font-size: 10px; text-shadow: 1px 1px 1px black; }

    .res-bar-container {
        width: 100%; height: 6px; background: #333; position: relative; margin-top: 2px;
        border: 1px solid #555;
    }
    .res-bar-fill { height: 100%; transition: width 0.3s; }
    .res-text { display: none; } /* Hide text for tiny bar, maybe tooltip? */

    .hero-panel.active { border-color: gold; box-shadow: 0 0 10px gold; }
    .hero-panel.dead { opacity: 0.5; filter: grayscale(100%); }
    
    .command-panel {
        margin-top: 10px; padding: 10px; background: #222; border: 2px solid #555;
        display: flex; flex-direction: column; gap: 10px;
    }
    .action-grid { display: flex; gap: 10px; flex-wrap: wrap; }
    
    .btn-action {
        padding: 10px 20px; background: #444; color: white; border: 1px solid #777;
        cursor: pointer; font-size: 1.1em; display: flex; flex-direction: column; align-items: center;
        min-width: 80px;
    }
    .btn-action:hover { background: #555; border-color: white; }
    .btn-action.active { background: #664400; border-color: gold; }
    .btn-action:disabled { opacity: 0.5; cursor: not-allowed; }
    
    .btn-action .cost { font-size: 0.7em; color: #aaaaff; }
    
    .target-prompt { color: gold; font-weight: bold; animation: pulse 1s infinite; }
    
    .btn-auto { margin-left: auto; background: #004444; color: #00ffff; border: 1px solid #00aaaa; padding: 5px 10px; cursor: pointer; }
    .btn-action.skill { background: #004400; border-color: #00aa00; }
    .btn-action.skill:hover { background: #005500; border-color: #00ff00; }

    .menu-title { font-weight: bold; color: gold; font-size: 1.2rem; }
    .sub-text { color: #aaa; font-size: 0.9rem; margin-bottom: 10px; }
    
    .btn-grid { display: flex; flex-direction: column; gap: 8px; width: 100%; }
    button { 
        background: #444; color: white; border: 1px solid #777; padding: 12px; cursor: pointer; 
        font-weight: bold; transition: all 0.2s; border-radius: 4px;
    }
    button:hover { background: #666; border-color: gold; }
    
    .btn-cancel { background: #822; }
    .btn-auto { background: #228; border-color: #66f; }
    .skip-btn { margin-top: 10px; color: #666; cursor: pointer; font-size: 0.8rem; }
    .skip-btn:hover { color: white; }

    /* LOOT UI */
    .loot-overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8); z-index: 5000;
        display: flex; justify-content: center; align-items: center;
        pointer-events: auto;
    }
    .loot-window {
        width: 400px; background: #222; border: 2px solid gold; border-radius: 8px;
        padding: 20px; display: flex; flex-direction: column; gap: 15px;
        box-shadow: 0 0 50px rgba(255, 215, 0, 0.3);
    }
    .loot-title { font-size: 2rem; color: gold; text-align: center; text-transform: uppercase; font-weight: bold; }
    .loot-gold { text-align: center; color: #ffaa00; font-size: 1.2rem; }
    
    .loot-grid { display: flex; flex-direction: column; gap: 10px; max-height: 400px; overflow-y: auto; }
    
    .loot-item {
        display: flex; gap: 10px; padding: 10px; background: #333; border: 1px solid #555; align-items: center;
    }
    .loot-item .item-icon { font-size: 2rem; }
    .loot-item .item-details { display: flex; flex-direction: column; }
    .loot-item .item-name { font-weight: bold; color: white; }
    .loot-item .item-type { font-size: 0.8rem; color: #aaa; }

    /* RARITY COLORS */
    .loot-item.Common { border-color: #9d9d9d; }
    .loot-item.Common .item-name { color: #dcdcdc; }

    .loot-item.Uncommon { border-color: #1eff00; background: rgba(30, 255, 0, 0.1); }
    .loot-item.Uncommon .item-name { color: #1eff00; }

    .loot-item.Rare { border-color: #0070dd; background: rgba(0, 112, 221, 0.1); }
    .loot-item.Rare .item-name { color: #0070dd; text-shadow: 0 0 5px #0070dd; }

    .loot-item.Epic { border-color: #a335ee; background: rgba(163, 53, 238, 0.15); }
    .loot-item.Epic .item-name { color: #a335ee; text-shadow: 0 0 8px #a335ee; }

    .loot-item.Legendary { border-color: #ff8000; background: rgba(255, 128, 0, 0.2); border-width: 2px; }
    .loot-item.Legendary .item-name { color: #ff8000; text-shadow: 0 0 10px #ff8000; }

    .btn-take {
        width: 100%; padding: 15px; background: gold; color: black; font-weight: bold;
        font-size: 1.2rem; border: none; cursor: pointer;
    }
    .btn-take:hover { background: #ffaa00; }
</style>
