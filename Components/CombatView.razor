@using StoneHammer.Systems
@inject CombatService CombatService
@implements IDisposable

@if (CombatService.IsFighting)
{
    <div class="combat-overlay">
        <!-- Top: Log -->
        <div class="combat-log">
            @CombatService.CombatLog
        </div>

        <!-- Floating Units (Positioned by JS) -->
        <!-- Enemies -->
        @foreach(var enemy in CombatService.Enemies)
        {
            @if (enemy.HP > 0)
            {
                <div id="@("ui-" + enemy.ModelId)" class="combat-unit enemy @(_targetMode ? "targetable" : "")" 
                     @onclick="() => SelectTarget(enemy)" style="display: none;"> <!-- Hidden until positioned -->
                    <div class="unit-name">@enemy.Name</div>
                    <div class="unit-hp-bar">
                        <div class="fill" style="width: @(GetHpPercent(enemy))%"></div>
                    </div>
                    <div class="unit-hp-text">@enemy.HP / @enemy.MaxHP</div>
                </div>
            }
        }

        <!-- Heroes -->
        @foreach(var hero in CombatService.Heroes)
        {
            @if (hero.HP > 0)
            {
                <div id="@("ui-" + hero.ModelId)" class="combat-unit hero @(_selectedHero == hero ? "selected" : "")"
                     @onclick="() => SelectHero(hero)" style="display: none;">
                    <div class="unit-model">@(hero.Name.Substring(0,1))</div>
                    <div class="unit-info">
                         <!-- Simplified for Floating UI -->
                        <div class="name">@hero.Name</div>
                        <div class="unit-hp-bar">
                            <div class="fill" style="width: @(GetHpPercent(hero))%"></div>
                        </div>
                        <div class="hp">@hero.HP / @hero.MaxHP</div>
                        <div class="action-preview">
                            @(hero.QueuedAction?.Type ?? "Wait")
                        </div>
                    </div>
                </div>
            }
        }

        <!-- Bottom Right: Command Menu (Fixed) -->
        <div class="command-panel-wrapper">
            @if (CombatService.Phase == CombatPhase.Input)
            {
                <div class="command-panel">
                    @if(_selectedHero != null && !_targetMode)
                    {
                        <div class="menu-title">@_selectedHero.Name</div>
                        <div class="btn-grid">
                            <button @onclick='() => BeginTargeting("Attack")'>‚öîÔ∏è Attack</button>
                            <button @onclick='() => QueueDirect("Heal")'>üíñ Heal</button>
                            <button @onclick='() => QueueDirect("Defend")'>üõ°Ô∏è Defend</button>
                        </div>
                    }
                    else if (_targetMode)
                    {
                        <div class="menu-title">SELECT TARGET</div>
                        <div class="sub-text">Click an enemy...</div>
                        <button class="btn-cancel" @onclick="CancelTargeting">Cancel</button>
                    }
                    else
                    {
                        <div class="menu-title">SELECT HERO</div>
                    }

                    <div style="display: flex; gap: 5px; margin-top: 10px;">
                        <button class="btn-fight" style="flex: 1;" @onclick="ExecuteRound">FIGHT!</button>
                        <button class="btn-auto @(CombatService.IsAutoBattling ? "active" : "")" @onclick="ToggleAuto">
                            @(CombatService.IsAutoBattling ? "ü§ñ" : "ü§ñ")
                        </button>
                    </div>
                </div>
            }
        </div>
    </div>
}

@code {
    private CombatEntity? _selectedHero;
    private bool _targetMode = false;
    private string _pendingAction = "";

    protected override void OnInitialized()
    {
        CombatService.OnStateChanged += StateHasChanged;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (CombatService.IsFighting)
        {
            // Tell JS to start tracking positions
            var ids = CombatService.Heroes.Concat(CombatService.Enemies).Select(x => x.ModelId).ToList();
            await CombatService.JS.InvokeVoidAsync("stoneHammer.startUITracking", ids);
        }
    }

    private void ToggleAuto()
    {
        CombatService.ToggleAutoBattle();
    }

    private void SelectHero(CombatEntity hero)
    {
        if (CombatService.Phase != CombatPhase.Input) return;
        if (hero.HP <= 0) return;
        
        _selectedHero = hero;
        _targetMode = false;
        StateHasChanged();
    }

    private void QueueDirect(string action)
    {
        if (_selectedHero == null) return;
        CombatService.QueueAction(_selectedHero, action);
        AutoSelectNext();
    }

    private void BeginTargeting(string action)
    {
        _pendingAction = action;
        _targetMode = true;
    }

    private void SelectTarget(CombatEntity target)
    {
        if (!_targetMode || _selectedHero == null) return;
        
        CombatService.QueueAction(_selectedHero, _pendingAction, target);
        _targetMode = false;
        AutoSelectNext();
    }

    private void CancelTargeting()
    {
        _targetMode = false;
    }

    private async Task ExecuteRound()
    {
        _selectedHero = null;
        await CombatService.ExecuteRound();
    }
    
    private void AutoSelectNext()
    {
        _selectedHero = CombatService.Heroes.FirstOrDefault(h => h.QueuedAction == null && h.HP > 0);
        StateHasChanged();
    }

    private int GetHpPercent(CombatEntity e) => (int)((float)e.HP / e.MaxHP * 100);

    public void Dispose()
    {
        CombatService.OnStateChanged -= StateHasChanged;
    }
}

<style>
    .combat-overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; z-index: 2000; font-family: 'Segoe UI', sans-serif;
    }
    
    .combat-log {
        position: absolute; top: 10%; width: 100%; text-align: center;
        text-shadow: 0 0 5px black; font-size: 1.5rem; color: #fff; font-weight: bold;
    }

    /* Floating Units */
    .combat-unit {
        position: absolute; /* Floating */
        width: 120px; padding: 5px; 
        background: rgba(0,0,0,0.7); border: 2px solid #555;
        border-radius: 6px; color: white; 
        transition: transform 0.1s; pointer-events: auto; cursor: pointer;
        display: flex; flex-direction: column; align-items: center;
        font-size: 12px;
        transform: translate(-50%, -100%); /* Center horizontally, sit ABOVE point */
    }
    
    .combat-unit.enemy:hover { border-color: red; z-index: 2020; }
    .combat-unit.hero:hover { border-color: gold; z-index: 2020; }
    
    .combat-unit.hero.selected { border-color: gold; box-shadow: 0 0 15px gold; }
    .combat-unit.targetable { border-color: red; box-shadow: 0 0 15px red; cursor: crosshair; }
    
    .unit-hp-bar { width: 100%; height: 4px; background: #333; margin: 2px 0; }
    .unit-hp-bar .fill { height: 100%; background: #00ff00; }
    .enemy .unit-hp-bar .fill { background: #ff0000; }

    /* Command Panel Fixed Bottom Left */
    .command-panel-wrapper {
        position: absolute; bottom: 20px; right: 20px; pointer-events: auto;
    }
    
    .command-panel {
        width: 200px; padding: 10px; background: rgba(0,0,30,0.9); 
        border: 2px solid gold; border-radius: 8px;
    }
    .menu-title { font-weight: bold; color: gold; text-align: center; margin-bottom: 5px; }
    .btn-grid { display: flex; flex-direction: column; gap: 4px; }
    button { background: #444; color: white; border: 1px solid #777; padding: 6px; cursor: pointer; }
    .btn-fight { background: #800; font-weight: bold; }
</style>
